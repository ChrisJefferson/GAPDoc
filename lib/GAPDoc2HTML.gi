#############################################################################
##
#W  GAPDoc2HTML.gi                 GAPDoc                        Frank Lübeck
##
#H  @(#)$Id: GAPDoc2HTML.gi,v 1.1.1.1 2001-01-05 13:37:49 gap Exp $
##
#Y  Copyright (C)  2000,  Frank Lübeck,  Lehrstuhl D für Mathematik,  
#Y  RWTH Aachen
##
##  The  files GAPDoc2HTML.g{d,i}  contain  a  conversion program  which
##  produces from a  GAPDoc XML-document an HTML version for reading the
##  document with a Web-browser.
##  

##  REMARKS:
##  
##  We add a link to the document root to all recursively called functions
##  by adding .root entries.    The toc-, index- and  bib-information   is
##  collected in the root.
##  
##  The set of elements is partitioned into two subsets - those which
##  contain whole paragraphs and those which don't. 
##  
##  The     handler    of   a   paragraph     containing    element   (see
##  GAPDoc2HTMLProcs.ParEls below)  gets a  list as  argument to  which it
##  adds entries pairwise:   the first of such a   pair is  the  paragraph
##  counter (like [3,2,1,5] meaning Chap.3,   Sec.2, Subsec.1, Par.5)  and
##  the second is the formatted text of this paragraph.
##  
##  Some   handlers  of paragraph   containing  elements do the formatting
##  themselves (e.g., .List), the others are handles in the main recursion
##  function `GAPDoc2HTMLContent'.
##  
##  We produce  a full version of  the document  in text format, including
##  title   page, abstract and  other front   matter,  table of  contents,
##  bibliography (via   BibTeX-data  files) and  index.  Highlighting with
##  colors for ANSI color sequence capable terminals is included.
##  
##  In   this text converter  we also   produce  the manual.six  data. For
##  getting page  numbers in .dvi  and .pdf  versions, the LaTeX-converter
##  and LaTeX must be run first. This produces a .pnr file.
##  

#<#GAPDoc Label="GAPDoc2HTML">
#<#/GAPDoc>
#<#GAPDoc Label="GAPDoc2HTMLPrintHTMLFiles">
#<#/GAPDoc>
GAPDoc2HTMLProcs := rec();

##  Some text attributes ([begin, end] pairs)
GAPDoc2HTMLProcs.TextAttr := rec();
GAPDoc2HTMLProcs.TextAttr.Heading := ["", ""];

GAPDoc2HTMLProcs.TextAttr.Func := ["<code>", "</code>"];
GAPDoc2HTMLProcs.TextAttr.Arg := ["<var>", "</var>"];
GAPDoc2HTMLProcs.TextAttr.Example := ["", ""];
GAPDoc2HTMLProcs.TextAttr.Package := ["<strong class=\"pkg\">", "</strong>"];
GAPDoc2HTMLProcs.TextAttr.URL := ["", ""];
GAPDoc2HTMLProcs.TextAttr.Mark := ["<strong>", "</strong>"];

GAPDoc2HTMLProcs.TextAttr.K := ["<code>", "</code>"];
GAPDoc2HTMLProcs.TextAttr.C := ["<code>", "</code>"];
GAPDoc2HTMLProcs.TextAttr.F := ["<code>", "</code>"];
GAPDoc2HTMLProcs.TextAttr.I := ["<code class=\"i\">", "</code>"];
GAPDoc2HTMLProcs.TextAttr.B := ["<strong class=\"button\">", "</strong>"];
GAPDoc2HTMLProcs.TextAttr.Emph := ["<em>", "</em>"];

GAPDoc2HTMLProcs.TextAttr.Ref := ["<b>", "</b>"];

# like in Text converter, but a heading is not a paragraph here
GAPDoc2HTMLProcs.ParEls := 
[ "Display", "Example", "Log", "Listing", "List", "Enum", "Item", "Table", 
  "TitlePage", "Abstract", "Copyright", "Acknowledgements", "Colophon", 
  "TableOfContents", "Bibliography", "TheIndex", "Subsection", "ManSection", 
  "Description", "Section", "Chapter", "Appendix", "Body", "Book", 
  "WHOLEDOCUMENT", "Attr", "Fam", "Filt", "Func", "InfoClass", 
  "Meth", "Oper", "Prop", "Var" ];

##  arg: a list of strings
##  for now only ??????
SetGapDocTxtOptions := function(arg)    
  local   gdp;
  gdp := GAPDoc2HTMLProcs;
  return;  
end;



GAPDoc2HTMLProcs.Head1 := "\
<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \
\"http://www.w3.org/TR/REC-html40/strict.dtd\">\n\
<html><head>\n\
<title>GAP (";

GAPDoc2HTMLProcs.Head2 := "\
</title>\n\
<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\">\n\
<meta name=\"generator\" content=\"GAPDoc2HTML\">\n\
<link rel=stylesheet type=\"text/css\" href=\"manual.css\">\n\
</head>\n<body>\n";

GAPDoc2HTMLProcs.Tail := "\n\
<hr>\n\
<font size=\"small\">generated by GAPDoc2HTML</font>\
\n</body>\n</html>\n";  

GAPDoc2HTMLProcs.PutFilesTogether := function(l, r)
  local   files,  n,  tt,  i;
  
  # putting the paragraphs together (one string (file) for each chapter)
  files := rec();
  for n in Set(List([2,4..Length(l)], i-> l[i-1][1])) do
    files.(n) := rec(text := ShallowCopy(GAPDoc2HTMLProcs.Head1), ssnr := []);
    tt := Concatenation(r.bookname, ") - ");
    if n=0 then
      Append(tt, "Contents");
    elif IsInt(n) then
      Append(tt, Concatenation("Chapter ", String(n), ": ", r.chaptitle.(n)));
    elif n="Bib" then
      Append(tt, "References");
    elif n="Ind" then
      Append(tt, "Index");
    else
      Append(tt, Concatenation("Appendix ", n, ": ", r.chaptitle.(n)));
    fi;
    Append(files.(n).text, tt);
    Append(files.(n).text, GAPDoc2HTMLProcs.Head2);
  od;
  for i in [2,4..Length(l)] do
    n := files.(l[i-1][1]);
    if Length(n.ssnr)=0 or l[i-1]{[1..3]} <> n.ssnr[Length(n.ssnr)] then
      Add(n.ssnr, l[i-1]{[1..3]});
      Append(n.text, Concatenation("<a name=\"", GAPDoc2HTMLProcs.SectionLabel(
              l[i-1], "Subsection")[2], "\"></a>\n"));
    fi;

    Append(n.text, l[i]);
  od;
  
  for n in Set(List([2,4..Length(l)], i-> l[i-1][1])) do
    Append(files.(n).text, GAPDoc2HTMLProcs.Tail);
  od;
  return files;
end;

##  the basic call, used recursively with a result r from GetElement 
##  and a string str or list l to which the output should be appended
# arg: r[, bibpath]    (then a list is returned, only for whole document)
# or:  r, str          (then the output is appended to string or list str)
GAPDoc2HTML := function(arg)
  local   r,  str,  linelength,  name;
  r := arg[1];
  if Length(arg)=2 then
    str := arg[2];
  else 
    str := [];
  fi;
  
  if r.name = "WHOLEDOCUMENT" then
    if IsDirectory(str) then
      r.bibpath := str;
    else
      r.bibpath := Directory(str);
    fi;
    str := [];
  fi;

  name := r.name;
  if not IsBound(GAPDoc2HTMLProcs.(name)) then
    Print("WARNING: Don't know how to process element ", name, 
          " ---- ignored\n");
  else
    GAPDoc2HTMLProcs.(r.name)(r, str);
  fi;
  
  if r.name ="WHOLEDOCUMENT" then
    # put final record together and return i
    return GAPDoc2HTMLProcs.PutFilesTogether(str, r);
  fi;

  return str;
end;

##  recursion through the tree and collecting paragraphs
GAPDoc2HTMLContent := function(r, l)
  local   par,  cont,  count,  s,  a;
  
  # utility: append counter and formatted paragraph to l
  par := function(s)
    if Length(s)>0 then
# ??? formatting useful???      s := FormatParagraph(s, r.root.linelength);
      s := NormalizedWhitespace(s);
      if Length(s)>0 then
        Add(l, count);
        Add(l, Concatenation("<p>", s, "</p>\n\n"));
      fi;
    fi;
  end;
  
  # if not containing paragraphs, then l is string to append to
  if not r.name in GAPDoc2HTMLProcs.ParEls then
    for a in r.content do
      GAPDoc2HTML(a, l);
    od;
    return;
  fi;
  
  # otherwise we have to collect text and paragraphs
  cont := r.content;
  count := r.count;
  s := "";
  for a in cont do
    if a.count <> count  then
      par(s);
      count := a.count;
      s := "";
    fi;
    if a.name in GAPDoc2HTMLProcs.ParEls then
      # recursively collect paragraphs
      GAPDoc2HTML(a, l);
    else 
      # collect text for current paragraph
      GAPDoc2HTML(a, s);
    fi;
  od;
  if Length(s)>0 then
    par(s);
  fi;
end;

  
##  write head and foot of Txt file.
GAPDoc2HTMLProcs.WHOLEDOCUMENT := function(r, par)
  local   i,  pi,  t,  el,  a,  str,  bib,  keys,  need,  labels,  
          diff,  text,  stream;
  
  ##  add paragraph numbers to all nodes of the document
  AddParagraphNumbersGapDocTree(r);
  
  ##  add a link .root to the root of the document to all nodes
  ##  (then we can collect information about indexing and so on 
  ##  there)
  AddRootParseTree(r);
  r.index := [];
  r.toc := "";
  r.labels := rec();
  r.bibkeys := [];
  r.chaptitle := rec();
  
  ##  checking for processing instructions before the book starts
  ##  example:  <?HTML option1="value1" ?>
  i := 1;
  pi := rec();
  while not r.content[i].name = "Book" do
    if r.content[i].name = "XMLPI" then
      t := r.content[i].content;
      if Length(t) > 4 and t{[1..5]} = "HTML " then
        el := GetSTag(Concatenation("<", t, ">"), 2);
        for a in NamesOfComponents(el.attributes) do
          pi.(a) := el.attributes.(a);
        od;
      fi;
    fi;
    i := i+1;
  od;
  
  ##  Now the actual work starts, we give the processing instructions found
  ##  so far to the Book handler.
  ##  We call the Book handler twice and produce index, bibliography, toc
  ##  in between.
  Print("#I  first run, collecting cross references, index, toc, bib ",
        "and so on . . .\n");
  GAPDoc2HTMLProcs.Book(r.content[i], [], pi);
  
  # now the toc is ready
  Print("#I  table of contents complete.\n");
  r.toctext := r.toc;
  
  # .index has entries of form [sorttext, subtext, numbertext, entrytext]
  Print("#I  producing the index . . .\n");
  Sort(r.index);
  str := "";
  for a in r.index do
    Append(str, a[4]);
    if Length(a[2])>0 then
      Append(str, ", ");
      Append(str, a[2]);
    fi;
    Append(str, "  ");
    Append(str, a[3]);
    Add(str, '\n');
  od;
  r.indextext := str;
  
  if Length(r.bibkeys)>0 then
    Print("#I  reading bibliography data files . . . \n");
    bib := CallFuncList(ParseBibFiles, List(SplitString(
                    r.bibdata, "", ", \t\t\n"), f-> Filename(r.bibpath, f)));
    keys := Immutable(Set(r.bibkeys));
    need := [];
    for a in bib[1] do
      if a.Label in keys then
        NormalizeNameAndKey(a);
        Add(need, a);
      fi;
    od;
    SortParallel(List(need, a-> a.keylong), need);
    keys := List(need, a-> a.Label);
    labels := List(need, a-> a.key);
    diff := Difference(r.bibkeys, keys);
    if Length(diff) > 0 then
      Print("#W  could not find references: ", diff, "\n");
    fi;
    r.bibkeys := keys;
    r.biblabels := labels;
    Print("#I  writing bibliography . . .\n");
    text := "";
    stream := OutputTextString(text, false);
    PrintTo1(stream, function()
    for a in need do PrintBibAsText(a, true); od;
    end);
    CloseStream(stream);
    r.bibtext := text;
  fi;
  
  # second run
  r.index := [];
  Print("#I  second run through document . . .\n");
  GAPDoc2HTMLProcs.Book(r.content[i], par, pi);
  
  ##  remove the links to the root  ???
##    RemoveRootParseTree(r);
end;

##  comments and processing instructions are in general ignored
GAPDoc2HTMLProcs.XMLPI := function(r, str)
  return;
end;
GAPDoc2HTMLProcs.XMLCOMMENT := function(r, str)
  return;
end;

# just process content 
GAPDoc2HTMLProcs.Book := function(r, par, pi)
  # copy the name of the book to the root
  r.root.bookname := r.attributes.Name;
  GAPDoc2HTMLContent(r, par);
end;

##  Body is sectioning element
GAPDoc2HTMLProcs.Body := GAPDoc2HTMLContent;

##  the title page,  the most complicated looking function
GAPDoc2HTMLProcs.TitlePage := function(r, par)
  local   strn,  l,  s,  a,  aa,  cont,  ss;
    
  strn := "<div align=\"center\">\n";
  # title
  l := Filtered(r.content, a-> a.name = "Title");
  s := "";
  GAPDoc2HTMLContent(l[1], s);
  s := Concatenation("\n<h1>", NormalizedWhitespace(s), "</h1>\n\n"); 
  Append(strn, s);
  
  # subtitle
  l := Filtered(r.content, a-> a.name = "Subtitle");
  if Length(l)>0 then
    s := "";
    GAPDoc2HTMLContent(l[1], s);
    s := Concatenation("\n<h2>", NormalizedWhitespace(s), "</h2>\n\n"); 
    Append(strn, s);
  fi;
  
  # version
  l := Filtered(r.content, a-> a.name = "Version");
  if Length(l)>0 then
    s := "<p>(";
    GAPDoc2HTMLContent(l[1], s);
    while Length(s)>0 and s[Length(s)] in  WHITESPACE do
      Unbind(s[Length(s)]);
    od;
    Append(s, ")</p>\n\n");
    Append(strn, s);
  fi;

  # date
  l := Filtered(r.content, a-> a.name = "Date");
  if Length(l)>0 then
    s := "<p>";
    GAPDoc2HTMLContent(l[1], s);
    Append(strn, s);
    Append(strn, "</p>\n\n");
  fi;
  Append(strn, "</div>\n");
  
  # author name(s)
  l := Filtered(r.content, a-> a.name = "Author");
  for a in l do
    s := "<p><b>";
    aa := ShallowCopy(a);
    aa.content := Filtered(a.content, b-> not b.name in ["Email", "Homepage"]);
    GAPDoc2HTMLContent(aa, s);
    Append(strn, s);
    Append(strn, "</b>\n");
    cont := List(a.content, b-> b.name);
    if "Email" in cont then
      s := "";
      GAPDoc2HTML(a.content[Position(cont, "Email")], s);
      s := NormalizedWhitespace(s);
      Append(strn, Concatenation("<br>e-mail: ", s, "\n"));
    fi;
    if "Homepage" in cont then
      s := "";
      GAPDoc2HTML(a.content[Position(cont, "Homepage")], s);
      s := NormalizedWhitespace(s);
      Append(strn, Concatenation("<br>WWW: ", s, "\n"));
    fi;
    Append(strn, "</p>");
  od;
  Append(strn, "\n\n");
  
  Add(par, r.count);
  Add(par, strn);
  
  # abstract, copyright page, acknowledgements, colophon
  for ss in ["Abstract", "Copyright", "Acknowledgements", "Colophon" ] do
    l := Filtered(r.content, a-> a.name = ss);
    if Length(l)>0 then
      Add(par, l[1].count);
      Add(par, Concatenation("<h3>", ss, "</h3>\n"));
      GAPDoc2HTMLContent(l[1], par);
    fi;
  od;
end;

##  these produce text for an URL
##  ~ and # characters are correctly escaped
##  arg:  r, str[, pre]
GAPDoc2HTMLProcs.URL := function(arg)
  local   r,  str,  pre,  s,  p;
  r := arg[1];
  str := arg[2];
  if Length(arg)>2 then
    pre := arg[3];
  else
    pre := "";
  fi;
  
  s := "";
  GAPDoc2HTMLContent(r, s);
  Append(str, Concatenation("<a href=\"", pre, s, "\">", s, "</a>"));
end;

GAPDoc2HTMLProcs.Homepage := GAPDoc2HTMLProcs.URL;

GAPDoc2HTMLProcs.Email := function(r, str)
  # we add the `mailto://' phrase
  GAPDoc2HTMLProcs.URL(r, str, "mailto://");
end;

##  utility: generate a chapter or (sub)section-number string 
GAPDoc2HTMLProcs.SectionNumber := function(count, sect)
  local   res;
  if IsString(count[1]) or count[1]>0 then
    res := Concatenation(String(count[1]), ".");
  else
    res := "";
  fi;
  if sect="Chapter" then
    return res;
  fi;
  if count[2]>0 then
    Append(res, String(count[2]));
  fi;
  if sect="Section" then
    return res;
  fi;
  if count[3]>0 then
    Append(res, Concatenation("-", String(count[3])));
  fi;
  return res;
end;

##  utility: generate a chapter or (sub)section-number string 
GAPDoc2HTMLProcs.SectionLabel := function(count, sect)
  local   res;
  if IsString(count[1]) or count[1]>0 then
    res := Concatenation("chap", String(count[1]), ".html");
  else
    res := "chap0.html";
  fi;
  res := [res, ""];
  if sect="Chapter" then
    return res;
  fi;
  Append(res[2], Concatenation("s", String(count[2])));
  Append(res[2], Concatenation("ss", String(count[3])));
  return res;
end;

##  the sectioning commands are just translated and labels are
##  generated, if given as attribute
GAPDoc2HTMLProcs.ChapSect := function(r, par, sect)
  local   types,  nrs,  hord,  num,  posh,  s,  lab;
  
  types := ["Chapter", "Appendix", "Section", "Subsection"];
  nrs := ["3", "3", "4", "5"];
  hord := nrs[Position(types, sect)];
  
  # section number as string
  num := GAPDoc2HTMLProcs.SectionNumber(r.count, sect);
  
  # the heading
  posh := Position(List(r.content, a-> a.name), "Heading");
  if posh <> fail then      
    s := "";
    GAPDoc2HTMLProcs.Heading1(r.content[posh], s);
    if hord = "3" then
      r.root.chaptitle.(r.count[1]) := s;
    fi;
    
    # the heading text
    s := Concatenation("\n<h", hord, ">", num, " ", s, "</h", hord, ">\n\n");
    Add(par, r.count);
    Add(par, s);
    
    # table of contents entry
    lab := GAPDoc2HTMLProcs.SectionLabel(r.count, "Subsection");
    lab := Concatenation(lab[1], "#", lab[2]);
    Append(r.root.toc, Concatenation("<a href=\"", lab, "\">", s, "</a>"));
  fi;
  
  # label entry, if present
  if IsBound(r.attributes.Label) then
    r.root.labels.(r.attributes.Label) := [num, lab];
  fi;
  
  # the actual content
  GAPDoc2HTMLContent(r, par);
end;

##  this really produces the content of the heading
GAPDoc2HTMLProcs.Heading1 := function(r, str)
  GAPDoc2HTMLContent(r, str);
end;
##  and this ignores the heading (for simpler recursion)
GAPDoc2HTMLProcs.Heading := function(r, str)
end;

GAPDoc2HTMLProcs.Chapter := function(r, par)
  GAPDoc2HTMLProcs.ChapSect(r, par, "Chapter");
end;

GAPDoc2HTMLProcs.Appendix := function(r, par)
  GAPDoc2HTMLProcs.ChapSect(r, par, "Appendix");
end;

GAPDoc2HTMLProcs.Section := function(r, par)
  GAPDoc2HTMLProcs.ChapSect(r, par, "Section");
end;

GAPDoc2HTMLProcs.Subsection := function(r, par)
  GAPDoc2HTMLProcs.ChapSect(r, par, "Subsection");
end;

##  table of contents, just puts "TOC" in first run
GAPDoc2HTMLProcs.TableOfContents := function(r, par)
  Add(par, r.count);
  if IsBound(r.root.toctext) then
    Add(par, Concatenation("\n<h3>Contents</h3>\n\n",
          r.root.toctext, "<p> </p>\n\n"));
  else
    Add(par,"<p>TOC\n-----------</p>\n\n");
  fi;
end;

##  bibliography, just "BIB" in first run, store databases in root
GAPDoc2HTMLProcs.Bibliography := function(r, par)
  local   s;
  r.root.bibdata := r.attributes.Databases;
  Add(par, r.count);
  if IsBound(r.root.bibtext) then
    Add(par, Concatenation("\n<h3>References</h3>\n\n", 
            r.root.bibtext, "<p> </p>\n\n"));
  else
    Add(par,"<p>BIB\n-----------</p>\n");
  fi;
end;

##  We filter TeX commands and substitute \& -> & and so on, ~ -> NoBrkSpace
GAPDoc2HTMLProcs.PCDATAFILTER := function(r, str)
  local   cont,  lc,  i,  s,  j;
  cont := r.content;
  lc := Length(cont);
  i := 1;
  s := "";
  while i <= lc do
    if not cont[i] in "\\~" then
      j := i+1;
      while j <= lc and not cont[j] in "\\~" do
        j := j+1;
      od;
      Append(s, cont{[i..j-1]});
      i := j;
    elif cont[i] = '\\' then
      if i=lc then
        # trailing \ is removed
        break;
      elif cont[i+1] in LETTERS then
        # TeX command is removed
        j := i+2;
        while j <= lc and cont[j] in LETTERS do
          j := j+1;
        od;
        i := j;
      else
        # next character is considered to be escaped by the \
        # only the \ itself is removed
        Add(s, cont[i+1]);
        i := i+2;
      fi;
    elif cont[i] = '~' then
      # character 160 is a non-breakable space in iso-8859-1
      Add(s, CHAR_INT(160));
      i := i+1;
    fi;
  od;
  Append(str, s);
end;

##  inside <M> element we don't want this filtering
GAPDoc2HTMLProcs.PCDATANOFILTER := function(r, str)
  Append(str, r.content);
end;

## default is with filter
GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATAFILTER;

##  end of paragraph (end with double newline)
GAPDoc2HTMLProcs.P := function(r, str)
  # ??? automatic in HTML ???
##    local   l,  i;
##    l := Length(str);
##    if l>0 and str[l] <> '\n' then
##      Append(str, "\n\n");
##    elif l>1 and str[l-1] <> '\n' then
##      Add(str, '\n');
##    else
##      # remove too many line breaks
##      i := l-2;
##      while i>0 and str[i] = '\n' do
##        Unbind(str[i+2]);
##        i := i-1;
##      od;
##    fi;
end;

##  wrapping text attributes
GAPDoc2HTMLProcs.WrapAttr := function(r, str, a)
  local   s,  tt;
  s := "";
  GAPDoc2HTMLContent(r, s);
  tt := GAPDoc2HTMLProcs.TextAttr.(a);
  Append(str, Concatenation(tt[1], s, tt[2]));
end;

##  GAP keywords 
GAPDoc2HTMLProcs.K := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "K");
end;

##  buttons 
GAPDoc2HTMLProcs.B := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "B");
end;

##  verbatim GAP code
GAPDoc2HTMLProcs.C := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "C");
end;

##  file names
GAPDoc2HTMLProcs.F := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "F");
end;

##  argument names (same as Arg)
GAPDoc2HTMLProcs.A := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "Arg");
end;

##  simple maths, here we try to substitute TeX command to something which
##  looks ok in text mode
GAPDoc2HTMLProcs.M := function(r, str)
  local   subs,  s,  ss,  ls,  i,  j,  wd;
  # We do the following substitutions (for other TeX commands only the
  # backslash is removed.  Furthermore {} are changed to ().
  subs := rec(
              ldots := "...",
              mid := "|",
              left := "",
              right := "",
              mathbb := "",
              cdot := "*",
              geq := ">=",
              leq := "<=",
              pmod := "mod",
              equiv := "=",
              rightarrow := "->",
              to := "->",
              longrightarrow := "-->",
              mapsto := "->",            # or |->  ????
              leftarrow := "<-",
              langle := "<",
              rangle := ">"
              );
  s := "";
  # no filtering here
  GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATANOFILTER;
  GAPDoc2HTMLContent(r, s);
  GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATAFILTER;
  ss := "";
  ls := Length(s);
  i := 1;
  while i<=ls do
    if s[i] = '\\' and i<ls then
      if not s[i+1] in LETTERS then
        Add(ss, s[i+1]);
        i := i+2;
      else
        j := i+2;
        while j<=ls and s[j] in LETTERS do
          j := j+1;
        od;
        wd := s{[i+1..j-1]};
        if IsBound(subs.(wd)) then
          Append(ss, subs.(wd));
        else
          Append(ss, wd);
        fi;
        i := j;
      fi;
    elif s[i] = '{' then
      Add(ss, '(');  #???
      i := i+1;
    elif s[i] = '}' then
      Add(ss, ')');
      i := i+1;
    else
      j := i+1;
      while j <= ls and not (s[j] in "\\{}") do
        j := j+1;
      od;
      if i = 1 and j > ls then
        ss := s;
      else
        Append(ss, s{[i..j-1]});
      fi;
      i := j;
    fi;
  od;
  Append(str, ss);
#Print("\n------------\n",s,"\n",ss,"\n"); 
end;

##  in HTML this is shown in TeX format
GAPDoc2HTMLProcs.Math := function(r, str)
  Add(str, '$');
  GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATANOFILTER;
  GAPDoc2HTMLContent(r, str);
  GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATAFILTER;
  Add(str, '$');
end;

##  displayed maths (also in TeX format, but centered paragraph in itself)
GAPDoc2HTMLProcs.Display := function(r, par)
  local   s;
  s := "\\[";
  GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATANOFILTER;
  GAPDoc2HTMLContent(r, s);
  GAPDoc2HTMLProcs.PCDATA := GAPDoc2HTMLProcs.PCDATAFILTER;
  Append(s, " \\]");
  s := Concatenation("<p><div align=\"center\">", s, "</div></p>\n\n");
  Add(par, r.count);
  Add(par, s);
end;

##  emphazised text
GAPDoc2HTMLProcs.Emph := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "Emph");
end;

##  quoted text
GAPDoc2HTMLProcs.Q := function(r, str)
  Append(str, "``");
  GAPDoc2HTMLContent(r, str);
  Append(str, "''");
end;

##  Package names
GAPDoc2HTMLProcs.Package := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "Package");
end;

##  menu items
GAPDoc2HTMLProcs.I := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "I");
end;

GAPDoc2HTMLProcs.ExampleLike := function(r, par, label)
  local   str,  cont,  a,  s;
  str := "\n<table class=\"example\">\n<tr><td><pre>\n";
  cont := "";
  for a in r.content do 
    # here we try to avoid reformatting
    if IsString(a.content) then
      Append(cont, a.content); 
    else
      s := "";
      GAPDoc2HTML(a, s);
      Append(cont, s);
    fi;
  od;
  Append(str, cont);
  Append(str, "\n</pre></td></tr></table>\n\n");
  Add(par, r.count);
  Add(par, str);
end;

##  log of session and GAP code is typeset the same way as <Example>
GAPDoc2HTMLProcs.Example := function(r, par)
  GAPDoc2HTMLProcs.ExampleLike(r, par, "Example");
end;
GAPDoc2HTMLProcs.Log := function(r, par)
  GAPDoc2HTMLProcs.ExampleLike(r, par, "Log");
end;
GAPDoc2HTMLProcs.Listing := function(r, par)
  GAPDoc2HTMLProcs.ExampleLike(r, par, "Code");
end;

##  explicit labels
GAPDoc2HTMLProcs.Label := function(r, str)
  local num,  lab;
  num := GAPDoc2HTMLProcs.SectionNumber(r.count, "Subsection");
  lab := GAPDoc2HTMLProcs.SectionLabel(r.count, "Subsection"); 
  r.root.labels.(r.attributes.Name) := [num, Concatenation(lab[1],"#",lab[2])];
end;

##  citations
GAPDoc2HTMLProcs.Cite := function(r, str)
  local   key,  pos;
  key := r.attributes.Key;
  pos := Position(r.root.bibkeys, key);
  if pos = fail then
    Add(r.root.bibkeys, key);
    Append(str, Concatenation("[?", key, "?]"));
  elif  not IsBound(r.root.biblabels) then
    Append(str, Concatenation("[?", key, "?]"));
  else
    Append(str, Concatenation("[", r.root.biblabels[pos]));
    if IsBound(r.attributes.Place) then
      Append(str, ", ");
      Append(str, r.attributes.Place);
    fi;
    Add(str, ']');
  fi;
end;

##  explicit index entries
GAPDoc2HTMLProcs.Index := function(r, str)
  local   s,  entry;
  
  s := "";
  GAPDoc2HTMLContent(r, s);
  NormalizeWhitespace(s);
  if IsBound(r.attributes.Key) then
    entry := [STRING_LOWER(r.attributes.Key)];
  else
    entry := [STRING_LOWER(s)];
  fi;
  if IsBound(r.attributes.Subkey) then
    Add(entry, r.attributes.Subkey);
  else
    Add(entry, "");
  fi;
  Add(entry, GAPDoc2HTMLProcs.SectionNumber(r.count, "Subsection"));
  Add(entry, s);
  Add(entry, r.count{[1..3]});
  Add(r.root.index, entry);
end;

##  for argument list of functions (e.g., "a, b[[c, ], d]")
GAPDoc2HTMLProcs.NormalizedArgList := function(argl)
  local   sp,  res,  i;
  if Length(argl)=0  then
    return "";
  fi;
  sp := SplitString(argl, "", ", \n\r\t");
  res := sp[1];
  for i in [2..Length(sp)] do
    if not sp[i][1] in "[]" then
      Append(res, ", ");
    fi;
    Append(res, sp[i]);
  od;
  return res;
end;

##  this produces an implicit index entry and a label entry
GAPDoc2HTMLProcs.LikeFunc := function(r, par, typ)
  local   attr,  s,  name,  lab;
  attr := GAPDoc2HTMLProcs.TextAttr.Func;
  s := Concatenation(attr[1], "&gt; ", r.attributes.Name, attr[2]);
  if IsBound(r.attributes.Arg) then
    attr := GAPDoc2HTMLProcs.TextAttr.Arg;
    Append(s, Concatenation("( ", attr[1],
            GAPDoc2HTMLProcs.NormalizedArgList(r.attributes.Arg), 
            attr[2], " )"));
  fi;
  # index entry
  name := r.attributes.Name;
  attr := GAPDoc2HTMLProcs.TextAttr.Func;
  Add(r.root.index, [STRING_LOWER(name), "", 
          GAPDoc2HTMLProcs.SectionNumber(r.count, "Subsection"), 
          Concatenation(attr[1], name, attr[2]),
          r.count{[1..3]}]);
  # label (if not given, the default is the Name)
  if IsBound(r.attributes.Label) then
    lab := Concatenation(r.attributes.Name, r.attributes.Label);
  else
    lab := r.attributes.Name;  
  fi;
  GAPDoc2HTMLProcs.Label(rec(count := r.count, attributes := rec(Name
                                             := lab), root := r.root), par); 
  # adding  hint about the type of the variable  
  s := Concatenation("<p class=\"func\"><table class=\"func\" ", 
               "width=\"100%\">", 
               "<tr><td align=\"left\">", s,
               "</td><td align=\"right\">( ", typ, 
               " )</td></tr></table></p>\n");
  Add(par, r.count);
  Add(par, s);
end;

GAPDoc2HTMLProcs.Func := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "function");
end;

GAPDoc2HTMLProcs.Oper := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "operation");
end;

GAPDoc2HTMLProcs.Meth := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "method");
end;

GAPDoc2HTMLProcs.Filt := function(r, str)
  # r.attributes.Type could be "representation", "category", ...
  if IsBound(r.attributes.Type) then
    GAPDoc2HTMLProcs.LikeFunc(r, str, r.attributes.Type);
  else
    GAPDoc2HTMLProcs.LikeFunc(r, str, "filter");
  fi;
end;

GAPDoc2HTMLProcs.Prop := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "property");
end;

GAPDoc2HTMLProcs.Attr := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "attribute");
end;

GAPDoc2HTMLProcs.Var := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "global variable");
end;

GAPDoc2HTMLProcs.Fam := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "family");
end;

GAPDoc2HTMLProcs.InfoClass := function(r, str)
  GAPDoc2HTMLProcs.LikeFunc(r, str, "info class");
end;

##  using the HelpData(.., .., "ref") interface
GAPDoc2HTMLProcs.ResolveExternalRef := function(bookname,  label, nr)
  local info, match;
  info := HELP_BOOK_INFO(bookname);
  match := Concatenation(HELP_GET_MATCHES(info, STRING_LOWER(label), true));
  if Length(match) < nr then
    return fail;
  fi;
  return HELP_BOOK_HANDLER.(info.handler).HelpData(info, match[nr][2], "ref");
end;

GAPDoc2HTMLProcs.Ref := function(r, str)
  local   funclike,  int,  txt,  ref,  lab,  attr,  sectlike;
  
  int := Difference(NamesOfComponents(r.attributes), ["BookName", "Label"])[1];
  lab := r.attributes.(int);
  if IsBound(r.attributes.Label) then
    lab := Concatenation(lab, r.attributes.Label);
  fi;
  if IsBound(r.attributes.BookName) then
    ref := GAPDoc2HTMLProcs.ResolveExternalRef(r.attributes.BookName, lab, 1);
    if ref <> fail and ref[6] <> fail then
      ref := Concatenation("a href=\"", ref[6], "\"><b>", ref[1],
             "</b></a>");
    elif ref <> fail then
      ref := Concatenation("<b>", ref[1], "</b>");
    else
      ref := Concatenation("<b>", "???", "</b>");
    fi;
  else
    if IsBound(r.root.labels.(lab)) then
      ref := Concatenation("<a href=\"", r.root.labels.(lab)[2], "\">",
                           "<b>", r.root.labels.(lab)[1], "</b></a>");
    else
      ref := "<b>???</b>";
    fi;
  fi;
  if int in [ "Func", "Oper", "Meth", "Filt", "Prop", "Attr", "Var", 
                   "Fam", "InfoClass" ] then
    attr := GAPDoc2HTMLProcs.TextAttr.Func;
    txt := Concatenation(attr[1], r.attributes.(int), attr[2], " ");
  else
    txt := "";
  fi;
  Append(str, txt);
  Append(str, ref);
  return;
##   # function like cases
##   funclike := [ "Func", "Oper", "Meth", "Filt", "Prop", "Attr", "Var", 
##                 "Fam", "InfoClass" ];
##   int := Intersection(funclike, NamesOfComponents(r.attributes));
##   if Length(int)>0 then
##     txt := r.attributes.(int[1]);
##     if IsBound(r.attributes.BookName) then
##       ref := GAPDoc2HTMLProcs.ResolveExternalRef(r.attributes.BookName, 
##                       r.attributes.Label, 1);
##       if ref <> fail an ref[6] <> fail then
##         ref := Concatenation("<a href=\"", ref[6], "\">");
##       elif ref <> fail then
##         ref := Concatenation("<b>", ref[1], "</b>");
##       else 
##         ref := Concatenation("<b>", txt, "???</b>");
##       fi;
##     else
##       if IsBound(r.attributes.Label) then
##         lab := Concatenation(txt, r.attributes.Label);
##       else
##         lab := txt;
##       fi;
##       if IsBound(r.root.labels.(lab)) then
##         ref := Concatenation("<a href=\"", r.root.labels.(lab), "\">");
##       else
##         ref := "<b>???</b>";
##       fi;
##     fi;
##     attr := GAPDoc2HTMLProcs.TextAttr.Func;
##     Append(str, Concatenation(ref, attr[1], txt, attr[2]);
##     if Length(ref)>2 and ref{[1,2]} = "<a" then
##       Append(str, "</a>");
##     fi;
##     return;
##   fi;
##   
##   # section like cases
##   sectlike := ["Chap", "Sect", "Subsect", "Appendix"];
##   int := Intersection(sectlike, NamesOfComponents(r.attributes));
##   if Length(int)>0 then
##     if IsBound(r.attributes.BookName) then
##       ref := GAPDoc2HTMLProcs.ResolveExternalRef(r.attributes.BookName, 
##                      int[1], r.attributes.Label);
##       if ref.style = "noresolve" then
##         ref := ref.text;
##       fi;
##     else
##       # with sectioning references Label must be given
##       lab := r.attributes.(int[1]);
##       if IsBound(r.root.labels.(lab)) then
##         ref := r.root.labels.(lab);
##       else
##         ref := "???";
##       fi;
##     fi;
##     attr := GAPDoc2HTMLProcs.TextAttr.Ref;
##     Append(str, Concatenation(attr[1], ref, attr[2])); 
##     return;
##   fi;
##   
##   # neutral reference to a label
##   if IsBound(r.attributes.BookName) then
##     ref := GAPDoc2HTMLProcs.ResolveExternalRef(r.attributes.BookName, 
##                      "Label", r.attributes.Label);
##     if ref.style = "noresolve" then
##       ref := ref.text;
##     fi;
##   else
##     lab := r.attributes.Label;
##     if IsBound(r.root.labels.(lab)) then
##       ref := r.root.labels.(lab);
##     else
##       ref := "???";
##     fi;
##   fi;
##   attr := GAPDoc2HTMLProcs.TextAttr.Ref;
##   Append(str, Concatenation(attr[1], ref, attr[2]));
##   return;
end;

GAPDoc2HTMLProcs.Description := GAPDoc2HTMLContent;

GAPDoc2HTMLProcs.ManSection := function(r, par)
  local   strn,  funclike,  i,  num,  s,  lab;
  
  strn := "";
  # function like elements
  funclike := [ "Func", "Oper", "Meth", "Filt", "Prop", "Attr", "Var", 
                "Fam", "InfoClass" ];
  
  # heading comes from name of first function like element
  i := 1;
  while not r.content[i].name in funclike do
    i := i+1;
  od;
  
  num := GAPDoc2HTMLProcs.SectionNumber(r.count, "Subsection");
  s := Concatenation(num, " ", r.content[i].attributes.Name);
  Add(par, r.count);
  Add(par, Concatenation("\n<h5>", s, "</h5>\n\n"));
  # append to TOC as subsection
  lab := GAPDoc2HTMLProcs.SectionLabel(r.count, "Subsection");
  lab := Concatenation(lab[1], "#", lab[2]);
  Append(r.root.toc, Concatenation("<a href=\"", lab, "\"><h5>", s, 
          "</h5></a>\n"));
  GAPDoc2HTMLContent(r, par);
end;

GAPDoc2HTMLProcs.Mark := function(r, str)
  GAPDoc2HTMLProcs.WrapAttr(r, str, "Mark");
end;

GAPDoc2HTMLProcs.Item := function(r, str)
#  local   s;
#  s := "";
  GAPDoc2HTMLContent(r, str);
#  Append(str, s);
end;

# must do the complete formatting 
GAPDoc2HTMLProcs.List := function(r, par)
  local   s,  a,  ss, i;
  s := "\n";
  if "Mark" in List(r.content, a-> a.name) then
    # a <dl> list
    Append(s, "<dl>\n");
    for a in r.content do
      if a.name = "Mark" then
        ss := "";
        GAPDoc2HTMLProcs.Mark(a, ss);
        Append(s, Concatenation("<dt>", ss, "</dt>\n"));
      elif a.name = "Item" then
        ss := "";
        GAPDoc2HTMLProcs.Item(a, ss);
        ss := Concatenation(Filtered(ss, IsString));
        ss := Concatenation("<dd>", ss, "</dd>\n");
        Append(s, ss);
      fi;
    od;
    Append(s, "</dl>\n");
  else
    # a <ul> list
    Append(s, "<ul>\n");
    for a in r.content do
      if a.name = "Item" then
        ss := "";
        GAPDoc2HTMLProcs.Item(a, ss);
        ss := Concatenation(Filtered(ss, IsString));
        Append(s, Concatenation("<li>", ss, "</li>\n"));
      fi;
    od;
    Append(s, "</ul>\n");
  fi;
  Add(par, r.count);
  Add(par, s);
end;

##  and this is an <ol> list
GAPDoc2HTMLProcs.Enum := function(r, par)
  local   s,  i,  a,  ss,  num;
  s := "";
  # a <ul> list
  Append(s, "<ol>\n");
  for a in r.content do
    ss := "";
    GAPDoc2HTMLProcs.Item(a, ss);
    Append(s, Concatenation("<li>", ss, "</li>\n"));
  od;
  Append(s, "</ol>\n");
  Add(par, r.count);
  Add(par, s);
end;

GAPDoc2HTMLProcs.TheIndex := function(r, par)
  local   s;
  
  # the text, if available
  Add(par, r.count);
  if IsBound(r.root.indextext) then
    Add(par, Concatenation("\n<h3>Index</h3>\n\n",
          r.root.toctext, "<p> </p>\n\n"));
  else
    Add(par,"<p>INDEX\n-----------</p>\n\n");
  fi;
end;

GAPDoc2HTMLProcs.Alt := function(r, str)
  if (IsBound(r.attributes.Only) and r.attributes.Only = "HTML") or
           (IsBound(r.attributes.Not) and r.attributes.Not <> "HTML") then
    GAPDoc2HTMLContent(r, str);
  fi;
end;

# copy a few entries with two element names
GAPDoc2HTMLProcs.E := GAPDoc2HTMLProcs.Emph;
GAPDoc2HTMLProcs.Keyword := GAPDoc2HTMLProcs.K;
GAPDoc2HTMLProcs.Code := GAPDoc2HTMLProcs.C;
GAPDoc2HTMLProcs.File := GAPDoc2HTMLProcs.F;
GAPDoc2HTMLProcs.Button := GAPDoc2HTMLProcs.B;
GAPDoc2HTMLProcs.Arg := GAPDoc2HTMLProcs.A;
GAPDoc2HTMLProcs.Quoted := GAPDoc2HTMLProcs.Q;
GAPDoc2HTMLProcs.Par := GAPDoc2HTMLProcs.P;

##  <!ELEMENT Table ( Caption?, (Row | HorLine)+ )>
##  <!ELEMENT Row   ( Item+ )>
##  <!ELEMENT HorLine EMPTY>
##  <!ELEMENT Caption ( %InnerText; )*>


##  Finally a function to print the text files:
GAPDoc2HTMLPrintHTMLFiles := function(t, path)
  local   a;
  if IsString(path) then
    path := Directory(path);
  fi;
  for a in NamesOfComponents(t) do
    FileString(Filename(path, Concatenation("chap",a,".html")), t.(a).text);
  od;
end;
